import type { ObjectId } from 'mongoose';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { AuthAbilityModel, AuthRoleModel } from '../models/auth.model';
import { UserModel } from '../models/user.model';
import { SECRET_KEY, IAcl, IAuthRole, IAuthAbility, IAuthAbilityWrapper } from '../types/auth.types';
import { IUser, UserData, USER_DATA } from '../types/user.types';

export class AuthService {
  public async findAllAbilityRules() {
    return await AuthAbilityModel.find().populate('usersId').lean();
  }

  public async findAllRoles() {
    return await AuthRoleModel.find().populate('abilities', 'usersId').lean();
  }

  public async createRole() {}
  public async readRole(id: ObjectId) {}
  public async updateRole() {}
  public async deleteRole() {}

  public async login(username: string, password: string) {
    async function comparePassword(text: string, hashPassword: string) {
      return bcrypt.compareSync(text, hashPassword);
    }

    async function createToken(params: string): Promise<string> {
      // const secret = process.env.JWT_SECRET_KEY || 'MOLINDO';
      return jwt.sign(params, SECRET_KEY, { algorithm: 'HS256' });
    }

    function mergeAbilities(data: IUser): {roles: string[], abilityRules: IAcl[]} {
      const seenIds = new Set<string>();
      const abilityRules: IAcl[] = [];
      const roles: string[] = [];

      if(data && data.userRoles.length > 0) {
        for(const role of data.userRoles as any[]) {
          roles.push(role.name);
          role.abilities.forEach((ability: IAuthAbilityWrapper) => {
            if(!seenIds.has(ability._id)) {
              seenIds.add(ability._id)
              abilityRules.push(ability.ability)
            }
          })
        }
      }

      if(data && data.userAbilities.length > 0) {
        for(const ability of data.userAbilities as any[]) {
          if(!seenIds.has(ability._id)) {
            seenIds.add(ability._id)
            abilityRules.push(ability.ability)
          }
        }
      }

      return {roles, abilityRules};
    }

    try {
      let isUser: IUser|null = null;
      let userData: UserData = { ...USER_DATA };
      let isPasswordValid: boolean = false;
      let accessToken: string = '';

      if(isNaN(parseInt(username))) {
        if(!isUser) {
          isUser = await UserModel.findOne().where({ email: username }).populate(
            {
              path: 'userRoles',
              populate: {
                path: 'abilities' 
              }
            })
          .populate('userAbilities')
          .lean();
        }

        if(!isUser) {
          isUser = await UserModel.findOne().where({ shortNik: username }).populate(
            {
              path: 'userRoles',
              populate: {
                path: 'abilities' 
              }
            })
          .populate('userAbilities')
          .lean();
        }
      } else {
        isUser = await UserModel.findOne().where({ nik: parseInt(username) }).populate(
          {
            path: 'userRoles',
            populate: {
              path: 'abilities' 
            }
          })
        .populate('userAbilities')
        .lean();
      }

      if(isUser !== null) {
        isPasswordValid = await comparePassword(password, isUser.password);
        if(!isPasswordValid) { throw new Error('Password salah/tidak sesuai') }

        accessToken = await createToken(isUser.password);
        const mergedAbilities = mergeAbilities(isUser);

        userData['_id'] = isUser._id as string;
        userData['fullName'] = (`${isUser.firstName} ${isUser.lastName}`).trim();
        userData['username'] = username;
        // userData['password'] = isUser.password;
        userData['avatar'] = isUser.avatar;
        userData['email'] = isUser.email;
        userData['role'] = mergedAbilities.roles;
        // userData['abilityRules'] = mergedAbilities.abilityRules;

        return {
          userAbilityRules: mergedAbilities.abilityRules,
          accessToken,
          userData
        }
      } else {
        throw new Error('Username tidak ditemukan.')
      }
    } catch (error) {
      throw error;
    }
  }

  public async register() {}
}